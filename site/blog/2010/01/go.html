<!doctype html>
<html lang=en>
  <head>
    <meta charset=utf-8>
    <title>Taking Go (the programming language) for a spin - Paul Smith</title>
    <meta name="description" content="Paul Smith, programmer, EveryBlock co-founder">
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Sans:regular,bold|Inconsolata">
    <!--[if gte IE 7]><!-->
    <link rel="stylesheet" media="screen, projection" href="/css/base.css" type="text/css">
    <!-- <![endif]-->
    <link rel="stylesheet" href="/css/syntax.css" type="text/css">
    <link rel="alternate" href="/atom.xml" type="application/atom+xml">
    <link rel="openid.server" href="http://www.myopenid.com/server/">
    <link rel="openid.delegate" href="http://pauladamsmith.myopenid.com/">
    <meta name="verify-v1" content="JGWpUVGeSZp407VK35oscFKsTMIEalzD8cTIBcScWNQ=">
    
  </head>
  <body>
    <div id="page">
      <header>
        <h1><a href="/">Paul Smith</a></h1>
        <nav>
          <ul>
            <li><a href="/about.html">About</a></li>
            <li><a href="/blog/">Blog</a></li>
            <li><a href="/articles/">Articles</a></li>
            <li><a href="/projects.html">Projects</a></li>
          </ul>
        </nav>
      </header>
      <div id="main">
        
<article class="post">
  <h1><a href="/blog/2010/01/go.html" title="Permalink to this post">Taking Go (the programming language) for a spin</a></h1>

  <time datetime="2010-01-12" pubdate>
    January 12, 2010
  </time>

  <p>The first thing I noticed is Go provides high-level abstractions for writing
networked clients and servers, even by the standards of conventionally
high-level languages like Python. Given Go's identification as a systems
programming language, this is initially surprising, because such languages
tend to be low-level for performance reasons (Go does expose a lot of
low-level interfaces through various packages like <code>os</code> and <code>syscall</code>), but it
makes sense that there would be good support for these things because Go is a
modern language designed by folks with many years of experience writing
networked servers.</p>
<p>Specifically, the <code>net</code> package provides the <code>Listener</code> and <code>Conn</code> types that
hide many of the details of setting up socket connections. A simple
<code>net.Listen("tcp", ":1234")</code> is enough to get the equivalent of a listener, or
server, socket. The <code>bufio</code> package provides buffered read methods,
simplifying common tasks like reading lines over a socket.</p>
<p>Let's dive in a take a look at one way to implement a classic echo server. I
tried to use Go's language features for concurrent communication, goroutines
and channels, at crucial points. Where a different implementation in different
language might fork a new process or spawn a new thread to handle a new client
connection, a goroutine was started and the details of the connection
communicated with a channel.</p>
<div class="codehilite"><pre>package main

import (
    &quot;net&quot;
    &quot;bufio&quot;
    &quot;strconv&quot;
    &quot;fmt&quot;
)

const PORT = 3540</pre></div>


<p>All Go programs must have a <code>package main</code>. We declare a number of packages to
be imported, <code>net</code> and <code>bufio</code> already mentioned, <code>strconv</code> for its conversion
function <code>Itoa()</code> that converts an integer to a string, and <code>fmt</code> for printing
strings to the console. Our echo server will listen on port 3540.</p>
<div class="codehilite"><pre>func main() {
    server, err := net.Listen(&quot;tcp&quot;, &quot;:&quot; + strconv.Itoa(PORT))
    if server == nil {
        panic(&quot;couldn't start listening: &quot; + err.String())
    }
    conns := clientConns(server)
    for {
        go handleConn(&lt;-conns)
    }
}</pre></div>


<p>Every Go program must have a function <code>main()</code> in its <code>package main</code>. We start
by declaring and initializing a new listener for our echo server. We choose
the more generic <code>net.Listen()</code> over <code>net.TCPListen()</code>, because we can
conveniently parameterize the type of the listener with a string to the first
argument of <code>Listen</code>. (It is generally preferred in Go to deal with the most
generic type, or interface, especially when writing function and method
signatures, and either allow a specific type to be inferred by the compiler or
specify it when declaring/initializing a variable.) <code>":" + strconv.Itoa(PORT)</code>
is a string concentation expression, and the port constant we defined earlier
is converted to a string. (Strictly, a numeric constant is not an integer of a
particular type, but the string conversion function works here because the
compiler converts the constant into the concrete type to match the function
signature.)</p>
<p>The idiom for Go when handling multiple return values where the last has an
error type is to check the main object for nil, and then <code>panic()</code> with the
stringified error object. This is generally preferred over printing to stderr
and using <code>os.Exit()</code>, because it gives callers higher up the stack the chance
to <code>recover()</code>, sort of a raise/catch exception flow.</p>
<p>Using Go's compact syntax for simultaneous declaration and initialization, we
set <code>conns</code> to the value of the function call <code>clientConns(server)</code>. This is
the channel we'll use for getting new client connections.</p>
<p>The equivalent of a infinite loop like <code>while True:</code> or <code>for (;;)</code> in Go is
<code>for { ... }</code>. Each time through the loop, we start a goroutine, calling
<code>handleConn</code> with the value of the receive operation on our client connections
channel. The unary receive operator <code>&lt;-</code> blocks until a value is available on
the channel, in our case, a new client having connected.</p>
<div class="codehilite"><pre>func clientConns(listener net.Listener) chan net.Conn {
    ch := make(chan net.Conn)
    i := 0
    go func() {
        for {
            client, err := listener.Accept()
            if client == nil {
                fmt.Printf(&quot;couldn't accept: &quot; + err.String())
                continue
            }
            i++
            fmt.Printf(&quot;%d: %v &lt;-&gt; %v\n&quot;, i, client.LocalAddr(), client.RemoteAddr())
            ch &lt;- client
        }
    }()
    return ch
}</pre></div>


<p>We create a new channel of type <code>net.Conn</code>, which corresponds to the type that
we'll get from calling <code>Accept()</code> on our listener connection object. We start
off a new, anonymous goroutine which runs in an infinite loop, constantly
accepting new connections. <code>listener.Accept()</code> blocks as long as there are no
new clients to deal with, but since we're running inside a goroutine and
"detached" from the main program flow, other already-connected clients can
continue to be handled without interruption (this is where a <code>fork()</code> or a new
thread would happen in a typical server). Instead of <code>panic()</code>ing here if
there is an error connecting with the client, we simply note it on the console
of the server and move on. We also keep track of the number of clients we've
seen with the counter <code>i</code>. <code>fmt.Printf()</code> works like you'd expect, though the
<code>%v</code> format is new to C programmers -- it prints a value in a default format
and works for any type, somewhat like <code>repr()</code> in Python.</p>
<p>The binary <code>&lt;-</code> communication operator is used to send the client, of type
<code>net.Conn</code> to the channel we created at the top. Go has lexical scope (and is
garbage-collected), so <code>ch</code> is available inside the anonymous goroutine and
after our function returns (because the infinite <code>Accept()</code>ing for-loop keeps
the goroutine alive).</p>
<div class="codehilite"><pre>func handleConn(client net.Conn) {
    b := bufio.NewReader(client)
    for {
        line, err := b.ReadBytes('\n')
        if err != nil { // EOF, or worse
            break
        }
        client.Write(line)
    }
}</pre></div>


<p>As we saw back in <code>main()</code>, <code>handleConn()</code> is invoked as a goroutine with each
new client connection (the connection being received from the other side of
the channel we just created). <code>bufio.NewReader()</code> wraps the client object with
a nicer interface for reading lines of bytes from. If we decided to use the
<code>Read()</code> method of the <code>net.Conn</code> object, our code would be more complex,
having to check for the substring "n" and testing for EOF. Instead, we can
treat this as a line-oriented protocol, and simply get a line and write it
back to the client, as long as there are lines to be read.</p>
<p><a href="https://gist.github.com/775764">Here's the whole thing</a>.</p>
<p>The idiom of getting new connections from a channel and starting a goroutine
to handle them is conceptually clean, and also happens to be a straightforward
way to write a multiplexing, concurrent server.</p>

  <nav>
      
      <div class="next">Next: <a href="/blog/2010/12/redis.html">I wrote an article about Redis</a> <b>»</b></div>
    </nav>
  </article>

      </div><!-- #main -->
      <div id="side">
        <div>
          
        </div>
      </div>
    </div><!-- #page -->
    <footer>
      ⓒ 2010 Paul Smith
    </footer>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.js"></script>

<script type="text/javascript">
// Google Analytics
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-304677-1']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
  </body>
</html>

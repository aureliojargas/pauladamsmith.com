<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8>
  <title>Redis: under the hood</title>
  <link rel="stylesheet" href="redis_under_the_hood/style.css" type="text/css">
  <link rel="alternate" type="application/rss+xml" href="http://feeds.feedburner.com/PaulSmith">
</head>
<body>
  <h1 id="redis-under-the-hood">Redis: under the hood</h1>

  <p><a href="http://code.google.com/p/redis/"><img alt="Redis logo" id="logo"
  src="redis_under_the_hood/redis.png" title="Redis" name="logo"></a></p>

  <p>How does the <a href="http://code.google.com/p/redis/">Redis</a> server
  work?</p>

  <p>I was curious to learn more about Redis&rsquo;s internals, so I&rsquo;ve
  been familiarizing myself with the source, largely by reading and jumping
  around in Emacs. After I had peeled back enough of the onion&rsquo;s layers,
  I realized I was trying to keep track of too many details in my head, and it
  wasn&rsquo;t clear how it all hung together. I decided to write out in
  narrative form how an instance of the Redis server starts up and initializes
  itself, and how it handles the request/response cycle with a client, as a way
  of explaining it to myself, hopefully in a clear fashion. Luckily, Redis has
  a nice, clean code base that is easy to read and follow along. Armed with a
  <a href="http://ctags.sourceforge.net/">TAGS</a> file, my
  <code>$EDITOR</code>, and GDB, I set out to see how it all works under the
  hood. (Incidentally, I was working with the Redis code base as of <a href=
  "http://github.com/antirez/redis/tree/b4f2e412d087bae0a523fe6ea40fcad30fe74b5b">
  commit b4f2e41</a>. Of course, internals such as I outline below are subject
  to change. However, the broad architecture of the server is unlikely to
  change very much, and I tried to keep that in mind as I went along.)</p>

  <p>This article examines server startup and takes a high-level view of the
  request/response processing cycle. In a subsequent article, I&rsquo;ll dive
  in to greater detail and trace a simple <code>SET</code>/<code>GET</code>
  command pair as they make their way through Redis.</p>

  <div class="toc">
    <ul>
      <li>
        <a href="#redis-under-the-hood">Redis: under the hood</a>

        <ul>
          <li>
            <a href="#startup">Startup</a>

            <ul>
              <li><a href=
              "#beginning-global-server-state-initialization">Beginning global
              server state initialization</a></li>

              <li><a href="#setting-up-command-table">Setting up command
              table</a></li>

              <li><a href="#loading-config-file">Loading config file</a></li>

              <li>
                <a href="#initserver"><code>initServer()</code></a>

                <ul>
                  <li>
                    <a href="#shared-objects">Shared objects</a>

                    <ul>
                      <li><a href="#shared-integers">Shared integers</a></li>
                    </ul>
                  </li>

                  <li><a href="#event-loop">Event loop</a></li>

                  <li><a href="#databases">Databases</a></li>

                  <li><a href="#tcp-socket">TCP socket</a></li>

                  <li><a href="#server-cron">Server cron</a></li>

                  <li><a href=
                  "#registering-connection-handler-with-event-loop">Registering
                  connection handler with event loop</a></li>

                  <li><a href="#opening-the-aof">Opening the AOF</a></li>
                </ul>
              </li>

              <li>
                <a href="#back-up-to-main">Back up to <code>main()</code></a>

                <ul>
                  <li><a href="#restoring-data">Restoring data</a></li>

                  <li><a href="#event-loop-setup">Event loop setup</a></li>

                  <li><a href="#entering-the-event-loop">Entering the event
                  loop</a></li>
                </ul>
              </li>
            </ul>
          </li>

          <li>
            <a href="#processing-a-request-returning-a-response">Processing a
            request &amp; returning a response</a>

            <ul>
              <li><a href="#handling-a-new-connection">Handling a new
              connection</a></li>

              <li><a href="#reading-a-command-from-a-client">Reading a command
              from a client</a></li>

              <li><a href="#executing-the-command-and-responding">Executing the
              command and responding</a></li>
            </ul>
          </li>

          <li><a href="#summary">Summary</a></li>

          <li><a href="#next-time-tracing-a-set-and-get">Next time &mdash;
          tracing a <code>SET</code> and <code>GET</code></a></li>
        </ul>
      </li>
    </ul>
  </div>

  <h2 id="startup">Startup</h2>

  <p>Let&rsquo;s begin with the <code>main()</code> function in
  <code>redis.c</code>.</p>

  <p><a href="redis_under_the_hood/startup.png"><img alt="Startup
  diagram" src="redis_under_the_hood/startup_th.png" title="Startup
  diagram"></a></p>

  <h3 id="beginning-global-server-state-initialization">Beginning global server
  state initialization</h3>

  <p>First, <code>initServerConfig()</code> is called. This partially
  initializes a variable <code>server</code>, which has the type <code>struct
  redisServer</code>, that serves as the global server state.</p>

  <div class="codehilite">
    <pre>
<span class="c1">// redis.h:338</span>
<span class="k">struct</span> <span class="n">redisServer</span> <span class=
"p">{</span>
    <span class="n">pthread_t</span> <span class=
"n">mainthread</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">port</span><span class=
"p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class=
"p">;</span>
    <span class="n">redisDb</span> <span class="o">*</span><span class=
"n">db</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="c1">// redis.c:69</span>
<span class="k">struct</span> <span class="n">redisServer</span> <span class=
"n">server</span><span class="p">;</span> <span class=
"cm">/* server global state */</span>
</pre>
  </div>

  <p>There are a huge number of members in this struct, but they generally fall
  into the following categories:</p>

  <ul>
    <li>general server state</li>

    <li>statistics</li>

    <li>configuration from config file</li>

    <li>replication</li>

    <li>sort parameters</li>

    <li>virtual memory config, state, I/O threads, &amp; stats</li>

    <li>zip structure</li>

    <li>event loop helpers</li>

    <li>pub/sub</li>
  </ul>

  <p>For example, this struct includes members that map to options in the
  configuration file (usually named <code>redis.conf</code>) such as the port
  the server listens on and how verbose logging should be, pointers to linked
  lists of connected clients and slave Redis servers as well as the Redis
  database(s) itself, and counters for statistics like the number of commands
  processed since startup.</p>

  <p><code>initServerConfig()</code> provides default values for the members
  that can be configured by the user via the <code>redis.conf</code> config
  file.</p>

  <h3 id="setting-up-command-table">Setting up command table</h3>

  <p>The next thing <code>main()</code> does is sort the table of Redis
  commands. These are defined in a global variable
  <code>readonlyCommandTable</code> which is an array of <code>struct
  redisCommand</code>s.</p>

  <div class="codehilite">
    <pre>
<span class="c1">// redis.c:70</span>
<span class="k">struct</span> <span class="n">redisCommand</span> <span class=
"o">*</span><span class="n">commandTable</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">redisCommand</span> <span class=
"n">readonlyCommandTable</span><span class="p">[]</span> <span class=
"o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">"get"</span><span class=
"p">,</span><span class="n">getCommand</span><span class=
"p">,</span><span class="mi">2</span><span class="p">,</span><span class=
"n">REDIS_CMD_INLINE</span><span class="p">,</span><span class=
"nb">NULL</span><span class="p">,</span><span class="mi">1</span><span class=
"p">,</span><span class="mi">1</span><span class="p">,</span><span class=
"mi">1</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"set"</span><span class=
"p">,</span><span class="n">setCommand</span><span class=
"p">,</span><span class="mi">3</span><span class="p">,</span><span class=
"n">REDIS_CMD_BULK</span><span class="o">|</span><span class=
"n">REDIS_CMD_DENYOOM</span><span class="p">,</span><span class=
"nb">NULL</span><span class="p">,</span><span class="mi">0</span><span class=
"p">,</span><span class="mi">0</span><span class="p">,</span><span class=
"mi">0</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"setnx"</span><span class=
"p">,</span><span class="n">setnxCommand</span><span class=
"p">,</span><span class="mi">3</span><span class="p">,</span><span class=
"n">REDIS_CMD_BULK</span><span class="o">|</span><span class=
"n">REDIS_CMD_DENYOOM</span><span class="p">,</span><span class=
"nb">NULL</span><span class="p">,</span><span class="mi">0</span><span class=
"p">,</span><span class="mi">0</span><span class="p">,</span><span class=
"mi">0</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"setex"</span><span class=
"p">,</span><span class="n">setexCommand</span><span class=
"p">,</span><span class="mi">4</span><span class="p">,</span><span class=
"n">REDIS_CMD_BULK</span><span class="o">|</span><span class=
"n">REDIS_CMD_DENYOOM</span><span class="p">,</span><span class=
"nb">NULL</span><span class="p">,</span><span class="mi">0</span><span class=
"p">,</span><span class="mi">0</span><span class="p">,</span><span class=
"mi">0</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"append"</span><span class=
"p">,</span><span class="n">appendCommand</span><span class=
"p">,</span><span class="mi">3</span><span class="p">,</span><span class=
"n">REDIS_CMD_BULK</span><span class="o">|</span><span class=
"n">REDIS_CMD_DENYOOM</span><span class="p">,</span><span class=
"nb">NULL</span><span class="p">,</span><span class="mi">1</span><span class=
"p">,</span><span class="mi">1</span><span class="p">,</span><span class=
"mi">1</span><span class="p">},</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="c1">// redis.h:458</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class=
"n">redisCommandProc</span><span class="p">(</span><span class=
"n">redisClient</span> <span class="o">*</span><span class=
"n">c</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="k">struct</span> <span class="n">redisCommand</span> <span class=
"p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class=
"n">name</span><span class="p">;</span>
    <span class="n">redisCommandProc</span> <span class=
"o">*</span><span class="n">proc</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">arity</span><span class=
"p">;</span>
    <span class="kt">int</span> <span class="n">flags</span><span class=
"p">;</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre>
  </div>

  <p>(Sidebar: a <code>redisCommand</code> struct keeps track of its name
  &mdash; the mnemonic, i.e., &ldquo;get&rdquo; &mdash; a pointer to the actual
  C function that performs the command, the command&rsquo;s arity, command
  flags such as whether it returns a bulk response, and a number of VM-specific
  members.)</p>

  <p>The read-only table is ordered in source code so that commands are grouped
  by category, such as string commands, list commands, set commands, etc., to
  make it easier for a programmer to scan the table for similar commands. The
  sorted table of commands is pointed to by the global variable
  <code>commandTable</code>, and is used to lookup Redis commands with a
  standard binary search (<code>lookupCommand()</code>, which returns a pointer
  to a <code>redisCommand</code>).</p>

  <h3 id="loading-config-file">Loading config file</h3>

  <p><code>main()</code> moves on to processing command-line options given by
  the user starting up the redis-server executable. Currently, there is only a
  single argument that Redis takes &mdash; aside from the usual version
  <code>-v</code> and help <code>-h</code> flags &mdash; which is a path to a
  config file. If the path is given, Redis loads the config file and overrides
  any defaults already set by <code>initServerConfig()</code> by calling
  <code>loadServerConfig()</code>. This function is fairly straightforward,
  looping over each line in the config file and converting values that match
  directive names to appropriate types for the matching member in the
  <code>server</code> struct. At this point, Redis will daemonize and detach
  from the controlling terminal if it has been configured to do so.</p>

  <h3 id="initserver"><code>initServer()</code></h3>

  <p><code>initServer()</code> finishes the job of initializing the
  <code>server</code> struct that was begun by <code>initServerConfig()</code>.
  First, it sets up signal handling (<code>SIGHUP</code> and
  <code>SIGPIPE</code> signals are ignored &mdash; there is an opportunity to
  improve Redis by adding the ability to reload its config file when it
  receives a <code>SIGHUP</code>, in the fashion of other daemons), including
  printing a stacktrace if the server receives a <code>SIGSEGV</code> (and
  other related signals), see <code>segvHandler()</code>.</p>

  <p>A number of doubly-linked lists (see <code>adlist.h</code>) are created to
  keep track of clients, slaves, monitors (a client that has sent the
  <code>MONITOR</code> command), and an object free list.</p>

  <h4 id="shared-objects">Shared objects</h4>

  <p>One interesting thing Redis does is create a number of shared objects,
  which are accessible via the global <code>shared</code> struct. Common Redis
  objects that are required by many different commands, response strings and
  error messages, for example, can be shared without having to allocate them
  each time, saving memory, with the tradeoff of a bit more initialization
  effort at startup time.</p>

  <div class="codehilite">
    <pre>
<span class="c1">// redis.c:662</span>
<span class="n">shared</span><span class="p">.</span><span class=
"n">crlf</span> <span class="o">=</span> <span class=
"n">createObject</span><span class="p">(</span><span class=
"n">REDIS_STRING</span><span class="p">,</span><span class=
"n">sdsnew</span><span class="p">(</span><span class="s">"</span><span class=
"se">\r\n</span><span class="s">"</span><span class="p">));</span>
<span class="n">shared</span><span class="p">.</span><span class=
"n">ok</span> <span class="o">=</span> <span class=
"n">createObject</span><span class="p">(</span><span class=
"n">REDIS_STRING</span><span class="p">,</span><span class=
"n">sdsnew</span><span class="p">(</span><span class=
"s">"+OK</span><span class="se">\r\n</span><span class="s">"</span><span class=
"p">));</span>
<span class="n">shared</span><span class="p">.</span><span class=
"n">err</span> <span class="o">=</span> <span class=
"n">createObject</span><span class="p">(</span><span class=
"n">REDIS_STRING</span><span class="p">,</span><span class=
"n">sdsnew</span><span class="p">(</span><span class=
"s">"-ERR</span><span class="se">\r\n</span><span class=
"s">"</span><span class="p">));</span>
<span class="n">shared</span><span class="p">.</span><span class=
"n">emptybulk</span> <span class="o">=</span> <span class=
"n">createObject</span><span class="p">(</span><span class=
"n">REDIS_STRING</span><span class="p">,</span><span class=
"n">sdsnew</span><span class="p">(</span><span class="s">"$0</span><span class=
"se">\r\n\r\n</span><span class="s">"</span><span class="p">));</span>
<span class="c1">// ...</span>
</pre>
  </div>

  <h5 id="shared-integers">Shared integers</h5>

  <p>Users of Redis will see the greatest impact in terms of memory savings
  from shared objects by the creation of a number of shared integers.</p>

  <div class="codehilite">
    <pre>
<span class="c1">// redis.c:705</span>
<span class="k">for</span> <span class="p">(</span><span class=
"n">j</span> <span class="o">=</span> <span class="mi">0</span><span class=
"p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class=
"n">REDIS_SHARED_INTEGERS</span><span class="p">;</span> <span class=
"n">j</span><span class="o">++</span><span class="p">)</span> <span class=
"p">{</span>
    <span class="n">shared</span><span class="p">.</span><span class=
"n">integers</span><span class="p">[</span><span class="n">j</span><span class=
"p">]</span> <span class="o">=</span> <span class=
"n">createObject</span><span class="p">(</span><span class=
"n">REDIS_STRING</span><span class="p">,(</span><span class=
"kt">void</span><span class="o">*</span><span class="p">)(</span><span class=
"kt">long</span><span class="p">)</span><span class="n">j</span><span class=
"p">);</span>
    <span class="n">shared</span><span class="p">.</span><span class=
"n">integers</span><span class="p">[</span><span class="n">j</span><span class=
"p">]</span><span class="o">-&gt;</span><span class=
"n">encoding</span> <span class="o">=</span> <span class=
"n">REDIS_ENCODING_INT</span><span class="p">;</span>
<span class="p">}</span>
</pre>
  </div>

  <p><code>createSharedObjects()</code> creates an array of the first 10,000
  non-negative integers as Redis objects (strings with an integer encoding).
  Various Redis objects like strings, sets, and lists often contain many small
  integers (for IDs or counters), and they can reuse the same objects already
  allocated in memory, for a large potential savings. One could imagine the
  constant that defines the number of shared integers to be created,
  <code>REDIS_SHARED_INTEGERS</code>, being exposed to configuration to give
  users the opportunity, based on knowledge of their applications and needs, to
  increase the number of shared integers for greater memory savings. The
  tradeoff is that Redis statically allocates slightly more memory at startup
  time, but this would likely be a small amount compared to the overall typical
  database sizes and potential savings.</p>

  <h4 id="event-loop">Event loop</h4>

  <p><code>initServer()</code> continues by creating the core event loop,
  calling <code>aeCreateEventLoop()</code> (see <code>ae.c</code>) and
  assigning the result to the <code>el</code> member of <code>server</code>.
  (Sidebar: one key aspect of Redis&rsquo;s implementation is the use of
  locally-provided wrappers to simplify and hide the complexity of common
  tasks, without adding dependecies at build-time. For example,
  <code>zmalloc.h</code> defines a number of wrappers for the family of
  <code>*alloc()</code> functions, which keep track of how much memory Redis
  has allocated. <code>sds.h</code> defines an API to a dynamic strings library
  (basically, a string that keeps track of its length and whether its memory
  can be freed). <code>ae.h</code> provides a platform-independent wrapper for
  setting up I/O event notification loops, which uses <code>epoll</code> on
  Linux, <code>kqueue</code> on BSD, and falls back to <code>select</code> if
  the respective first choice is not available.) Redis&rsquo;s event loop polls
  for new connections and I/O events (reading requests from and writing
  responses to a socket), being triggered when a new event arrives. This is
  what makes Redis so responsive, it can serve thousands of clients
  simultaneously without blockig while individual requests are processed and
  responded to.</p>

  <h4 id="databases">Databases</h4>

  <p><code>initServer()</code> also initializes a number of
  <code>redisDb</code> objects, which are structs that encapsulate the details
  of a particular Redis database, including tracking expiring keys, keys that
  are blocking (either from a <code>B{L,R}POP</code> command or from I/O), and
  keys that are being watched for check-and-set. (By default there are 16
  separate databases, which can be thought of as namespaces within a Redis
  server.)</p>

  <h4 id="tcp-socket">TCP socket</h4>

  <p><code>initServer()</code> is where the socket that Redis listens for
  connections (by default, bound to port 6379) is set up. Another Redis-local
  wrapper, <code>anet.h</code>, defines <code>anetTcpServer()</code> and a
  number of other functions that simplify the usual complexity of setting up a
  new socket, binding, and listening to a port.</p>

  <div class="codehilite">
    <pre>
<span class="c1">// redis.c:791</span>
<span class="n">server</span><span class="p">.</span><span class=
"n">fd</span> <span class="o">=</span> <span class=
"n">anetTcpServer</span><span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class=
"n">neterr</span><span class="p">,</span> <span class=
"n">server</span><span class="p">.</span><span class=
"n">port</span><span class="p">,</span> <span class=
"n">server</span><span class="p">.</span><span class=
"n">bindaddr</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class="n">fd</span> <span class=
"o">==</span> <span class="o">-</span><span class="mi">1</span><span class=
"p">)</span> <span class="p">{</span>
    <span class="n">redisLog</span><span class="p">(</span><span class=
"n">REDIS_WARNING</span><span class="p">,</span> <span class=
"s">"Opening TCP port: %s"</span><span class="p">,</span> <span class=
"n">server</span><span class="p">.</span><span class=
"n">neterr</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class=
"mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre>
  </div>

  <h4 id="server-cron">Server cron</h4>

  <p><code>initServer()</code> further allocates various dicts and lists for
  databases and for pub/sub, resets stats and various flags, and notes the UNIX
  timestamp of the server start time. It registers <code>serverCron()</code>
  with the event loop as a time event, executing that function once every 100
  milliseconds. (This is a bit tricky, because initially,
  <code>serverCron()</code> is set to run in 1 millisecond by
  <code>initServer()</code>, in order to have the cron cycle start right away
  with the server startup, but then the return value of
  <code>serverCron()</code>, which is 100, is plugged in to the calculation of
  the next time the time event process should be handled.)</p>

  <p><code>serverCron()</code> performs a number of periodic tasks for Redis,
  including verbose logging of database size (# of keys and memory used) and
  connected clients, resizing hash tables, closing idle/timed-out client
  connections, performing any post-background save or AOF rewrite cleanup,
  kicking off a background save if the save conditions as configured have been
  met (so many keys changed in so many seconds), calculating LRU information
  and dealing with expired keys (Redis only expires a few timed-out keys per
  cron cycle, using a adaptive, statistical method to avoid tying up the
  server, but will get more aggressive if expiring keys can help avoid
  out-of-memory situations), swapping out values to disk if virtual memory is
  enabled, and syncing with a master if this server is a slave.</p>

  <h4 id="registering-connection-handler-with-event-loop">Registering
  connection handler with event loop</h4>

  <p>Crucially, <code>initServer()</code> hooks up the event loop with the
  server&rsquo;s TCP socket by registering the socket&rsquo;s descriptor,
  registering the <code>acceptHandler()</code> function to be called when a new
  connection is accepted. (More on this below in the &ldquo;Processing a
  request&rdquo; section.)</p>

  <div class="codehilite">
    <pre>
<span class="c1">// redis.c:821</span>
<span class="k">if</span> <span class="p">(</span><span class=
"n">aeCreateFileEvent</span><span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class="n">el</span><span class=
"p">,</span> <span class="n">server</span><span class="p">.</span><span class=
"n">fd</span><span class="p">,</span> <span class=
"n">AE_READABLE</span><span class="p">,</span>
    <span class="n">acceptHandler</span><span class="p">,</span> <span class=
"nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class=
"n">AE_ERR</span><span class="p">)</span> <span class=
"n">oom</span><span class="p">(</span><span class=
"s">"creating file event"</span><span class="p">);</span>
</pre>
  </div>

  <h4 id="opening-the-aof">Opening the AOF</h4>

  <p><code>initServer()</code> creates or opens the append-only file (AOF), it
  the server was configured to use it.</p>

  <div class="codehilite">
    <pre>
<span class="c1">// redis.c:824</span>
<span class="k">if</span> <span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class=
"n">appendonly</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">server</span><span class="p">.</span><span class=
"n">appendfd</span> <span class="o">=</span> <span class=
"n">open</span><span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class=
"n">appendfilename</span><span class="p">,</span><span class=
"n">O_WRONLY</span><span class="o">|</span><span class=
"n">O_APPEND</span><span class="o">|</span><span class=
"n">O_CREAT</span><span class="p">,</span><span class=
"mo">0644</span><span class="p">);</span>
</pre>
  </div>

  <p>Finally, <code>initServer()</code> initializes Redis&rsquo;s virtual
  memory system, again, if the server had been configured for it.</p>

  <h3 id="back-up-to-main">Back up to <code>main()</code></h3>

  <p>If the server was configured to daemonize, Redis will now try to write out
  a pid file (the path of which is configurable, but defaults to
  <code>/var/run/redis.pid</code>).</p>

  <p>At this point, the server has started up, and Redis will log this fact to
  its log file. However, there&rsquo;s still a bit more to do in
  <code>main()</code> before Redis is fully ready.</p>

  <h4 id="restoring-data">Restoring data</h4>

  <p>If there is an AOF or a database dump file (eg., <code>dump.rdb</code>),
  it will be loaded, restoring data to the server from a previous session. (If
  both exist, the AOF takes priority.)</p>

  <div class="codehilite">
    <pre>
<span class="c1">// redis.c:1452</span>
<span class="k">if</span> <span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class=
"n">appendonly</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class=
"n">loadAppendOnlyFile</span><span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class=
"n">appendfilename</span><span class="p">)</span> <span class=
"o">==</span> <span class="n">REDIS_OK</span><span class="p">)</span>
        <span class="n">redisLog</span><span class="p">(</span><span class=
"n">REDIS_NOTICE</span><span class="p">,</span><span class=
"s">"DB loaded from append only file: %ld seconds"</span><span class=
"p">,</span><span class="n">time</span><span class="p">(</span><span class=
"nb">NULL</span><span class="p">)</span><span class="o">-</span><span class=
"n">start</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class=
"n">rdbLoad</span><span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class=
"n">dbfilename</span><span class="p">)</span> <span class=
"o">==</span> <span class="n">REDIS_OK</span><span class="p">)</span>
        <span class="n">redisLog</span><span class="p">(</span><span class=
"n">REDIS_NOTICE</span><span class="p">,</span><span class=
"s">"DB loaded from disk: %ld seconds"</span><span class=
"p">,</span><span class="n">time</span><span class="p">(</span><span class=
"nb">NULL</span><span class="p">)</span><span class="o">-</span><span class=
"n">start</span><span class="p">);</span>
<span class="p">}</span>
</pre>
  </div>

  <p>The server is now ready to start accepting requests.</p>

  <h4 id="event-loop-setup">Event loop setup</h4>

  <p>To finish up, Redis registers a function to be called each time it enters
  the event loop, <code>beforeSleep()</code> (since the process essentially
  goes to sleep while it waits to be notified of events).
  <code>beforeSleep()</code> does two things: it deals with serving clients
  that have requested keys that were swapped to disk if the virtual memory
  system was enabled, and it flushes the AOF to disk. The writing of the AOF is
  handled by <code>flushAppendOnlyFile()</code>. The function encapsulates some
  tricky logic about flushing the buffer that holds pending AOF writes (the
  frequency of which is configurable by the user).</p>

  <h4 id="entering-the-event-loop">Entering the event loop</h4>

  <p>Redis now enters the main event loop by calling <code>aeMain()</code>,
  with the argument <code>server.el</code> (remember, this member contains a
  pointer to an <code>aeEventLoop</code>). If there are any time (i.e., server
  cron) or file events to process each time through the loop, their respective
  handler functions will be called. <code>aeProcessEvents()</code> encapsulates
  this logic &mdash; time events are handled by custom logic, whereas file
  events are handled by the underlying <code>epoll</code> or
  <code>kqueue</code> or <code>select</code> I/O event notification system.</p>

  <p>Because of Redis&rsquo;s need to respond to time events as well as file or
  I/O events, it implements a custom event/polling loop, <code>aeMain()</code>.
  By checking to see if any time events need processing, and utilizing file
  event notification, the event loop can efficiently sleep until there is work
  to be done, and not tie up the CPU in a tight <code>while</code> loop.</p>

  <h2 id="processing-a-request-returning-a-response">Processing a request &amp;
  returning a response</h2>

  <p><a href="redis_under_the_hood/request-response.png"><img alt="Request/response
  diagram" src= "redis_under_the_hood/request-response_th.png"
  title="Request/response diagram"></a></p>

  <p>We are now inside Redis&rsquo;s main event polling loop, listening on a
  port and waiting for clients to connect. It&rsquo;s time to look at how Redis
  processes a command request.</p>

  <h3 id="handling-a-new-connection">Handling a new connection</h3>

  <p>Back under <code>initServer()</code>, Redis registered
  <code>acceptHandler()</code> to be called when there was an I/O event
  associated with the file descriptor of the socket the server is listening to
  (i.e., the socket has data waiting to be read or written).
  <code>acceptHandler()</code> creates a client object &mdash; pointer to a
  <code>redisClient</code>, a struct defined in <code>redis.h</code> &mdash; to
  represent a new client connection.</p>

  <div class="codehilite">
    <pre>
<span class="c1">// networking.c:347</span>
<span class="n">cfd</span> <span class="o">=</span> <span class=
"n">anetAccept</span><span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class=
"n">neterr</span><span class="p">,</span> <span class="n">fd</span><span class=
"p">,</span> <span class="n">cip</span><span class="p">,</span> <span class=
"o">&amp;</span><span class="n">cport</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class=
"n">cfd</span> <span class="o">==</span> <span class=
"n">AE_ERR</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">redisLog</span><span class="p">(</span><span class=
"n">REDIS_VERBOSE</span><span class="p">,</span><span class=
"s">"Accepting client connection: %s"</span><span class=
"p">,</span> <span class="n">server</span><span class="p">.</span><span class=
"n">neterr</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">redisLog</span><span class="p">(</span><span class=
"n">REDIS_VERBOSE</span><span class="p">,</span><span class=
"s">"Accepted %s:%d"</span><span class="p">,</span> <span class=
"n">cip</span><span class="p">,</span> <span class="n">cport</span><span class=
"p">);</span>
<span class="k">if</span> <span class="p">((</span><span class=
"n">c</span> <span class="o">=</span> <span class=
"n">createClient</span><span class="p">(</span><span class=
"n">cfd</span><span class="p">))</span> <span class="o">==</span> <span class=
"nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">redisLog</span><span class="p">(</span><span class=
"n">REDIS_WARNING</span><span class="p">,</span><span class=
"s">"Error allocating resoures for the client"</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class=
"n">cfd</span><span class="p">);</span> <span class=
"cm">/* May be already closed, just ingore errors */</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre>
  </div>

  <p><code>createClient()</code> is called to allocate and initialize the
  client object. It selects database 0 by default (since there has to be at
  least one Redis db per server), and associates the client file descriptor
  generated by <a href=
  "http://linux.die.net/man/2/accept"><code>accept(2)</code></a> in
  <code>acceptHandler()</code> with the client object. Other flags and members
  are initialized, and finally the client is appended to the global list of
  clients being tracked by <code>server.clients</code>. The key thing Redis
  does in <code>createClient()</code> is registering a handler with the event
  loop, the function <code>readQueryFromClient()</code>, for when there is data
  from the client connection to be read.</p>

  <div class="codehilite">
    <pre>
<span class="c1">// networking.c:20</span>
<span class="k">if</span> <span class="p">(</span><span class=
"n">aeCreateFileEvent</span><span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class="n">el</span><span class=
"p">,</span><span class="n">fd</span><span class="p">,</span><span class=
"n">AE_READABLE</span><span class="p">,</span> <span class=
"n">readQueryFromClient</span><span class="p">,</span> <span class=
"n">c</span><span class="p">)</span> <span class="o">==</span> <span class=
"n">AE_ERR</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">close</span><span class="p">(</span><span class=
"n">fd</span><span class="p">);</span>
    <span class="n">zfree</span><span class="p">(</span><span class=
"n">c</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class=
"p">;</span>
<span class="p">}</span>
</pre>
  </div>

  <h3 id="reading-a-command-from-a-client">Reading a command from a client</h3>

  <p><code>readQueryFromClient()</code> is called by the main event loop when
  the client makes a command request. (If you are debugging with GDB, this is a
  good function to set as a breakpoint.) It reads it as much as it can of the
  command &mdash; up to 1024 bytes &mdash; to a temporary buffer, then appends
  it to a client-specific query buffer. This allows Redis to process commands
  where the payload (command name plus arguments) is larger than 1024 bytes, or
  because of I/O reasons have been split up into multiple read events. It then
  calls <code>processInputBuffer()</code>, passing the client object as an
  argument.</p>

  <div class="codehilite">
    <pre>
<span class="c1">// networking.c:754</span>
<span class="kt">void</span> <span class=
"nf">readQueryFromClient</span><span class="p">(</span><span class=
"n">aeEventLoop</span> <span class="o">*</span><span class=
"n">el</span><span class="p">,</span> <span class="kt">int</span> <span class=
"n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class=
"o">*</span><span class="n">privdata</span><span class=
"p">,</span> <span class="kt">int</span> <span class=
"n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">redisClient</span> <span class="o">*</span><span class=
"n">c</span> <span class="o">=</span> <span class="p">(</span><span class=
"n">redisClient</span><span class="o">*</span><span class=
"p">)</span> <span class="n">privdata</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class=
"p">[</span><span class="n">REDIS_IOBUF_LEN</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">nread</span><span class=
"p">;</span>
    <span class="c1">// ...</span>

    <span class="n">nread</span> <span class="o">=</span> <span class=
"n">read</span><span class="p">(</span><span class="n">fd</span><span class=
"p">,</span> <span class="n">buf</span><span class="p">,</span> <span class=
"n">REDIS_IOBUF_LEN</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class=
"n">nread</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class=
"n">oldlen</span> <span class="o">=</span> <span class=
"n">sdslen</span><span class="p">(</span><span class="n">c</span><span class=
"o">-&gt;</span><span class="n">querybuf</span><span class="p">);</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class=
"n">querybuf</span> <span class="o">=</span> <span class=
"n">sdscatlen</span><span class="p">(</span><span class=
"n">c</span><span class="o">-&gt;</span><span class=
"n">querybuf</span><span class="p">,</span> <span class=
"n">buf</span><span class="p">,</span> <span class="n">nread</span><span class=
"p">);</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class=
"n">lastinteraction</span> <span class="o">=</span> <span class=
"n">time</span><span class="p">(</span><span class="nb">NULL</span><span class=
"p">);</span>
        <span class=
"cm">/* Scan this new piece of the query for the newline. We do this</span>
<span class=
"cm">         * here in order to make sure we perform this scan just one time</span>
<span class=
"cm">         * per piece of buffer, leading to an O(N) scan instead of O(N*N) */</span>
        <span class="k">if</span> <span class="p">(</span><span class=
"n">c</span><span class="o">-&gt;</span><span class=
"n">bulklen</span> <span class="o">==</span> <span class=
"o">-</span><span class="mi">1</span> <span class=
"o">&amp;&amp;</span> <span class="n">c</span><span class=
"o">-&gt;</span><span class="n">newline</span> <span class=
"o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class=
"n">newline</span> <span class="o">=</span> <span class=
"n">strchr</span><span class="p">(</span><span class="n">c</span><span class=
"o">-&gt;</span><span class="n">querybuf</span><span class=
"o">+</span><span class="n">oldlen</span><span class="p">,</span><span class=
"sc">'\n'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class=
"p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Processinputbuffer</span><span class=
"p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</pre>
  </div>

  <p><code>processInputBuffer()</code> parses the raw query from the client
  into arguments for execution of a Redis command. It first has to contend with
  the possibility that the client is blocked in a <code>B{L,R}POP</code>
  command, and bails early if that is the case. The function then parses the
  raw query buffer into arguments, creating Redis string objects of each and
  storing them in an array on the client object. The query is in the form of
  the <a href="http://code.google.com/p/redis/wiki/ProtocolSpecification">Redis
  protocol</a>. <code>processInputBuffer()</code> is really a protocol parser,
  calling back to <code>processCommand()</code> to fully parse the query.
  Somewhat confusingly, the source code comments describe parsing the
  &ldquo;multi bulk command type,&rdquo; an alternative protocol originally
  meant for commands like <code>MSET</code>, but it actually is now the main
  Redis protocol for all commands. It is binary-safe and easy to parse and
  debug. (Note: this code has been refactored for the upcoming 2.2 release and
  is a bit easier to follow.) Now it&rsquo;s time to actually execute the
  command the client has sent, by calling <code>processCommand()</code> on the
  client object.</p>

  <p><code>processCommand()</code> takes the arguments of a command from a
  client and executes it. Before it gets to the actual execution of the
  command, it performs a number of checks &mdash; if any check fails, it
  appends a error message to the client object&rsquo;s reply list and returns
  to the caller, <code>processInputBuffer()</code>. After handling the
  <code>QUIT</code> command as a special case (in order to shut down the client
  safely), <code>processCommand()</code> looks up the command name in the
  <code>commandTable</code> that was previously set up during Redis&rsquo;s
  start up cycle. If it&rsquo;s an unknown command, or the client got the arity
  of the command wrong, it&rsquo;s an error. While it&rsquo;s not commonly
  used, Redis can be configured to require a password to authenticate a client
  before it will accept commands, and this is the stage where Redis will check
  if the client is authenticate, and will set an error if not. If Redis is
  configured to use up to a maximum amount of memory, it will at this point try
  to free up memory if it can (be freeing objects from the free list and
  removing expired keys), otherwise if the server is over the limit, it
  won&rsquo;t process commands with the <code>REDIS_CMD_DENYOOM</code> flag set
  (mainly writes like <code>SET</code>, <code>INCR</code>, <code>RPUSH</code>,
  <code>ZADD</code>, etc.), again, an error. One final check Redis makes is
  that a client can only issue <code>SUBSCRIBE</code> or
  <code>UNSUBSCRIBE</code> commands while there are outstanding channels
  subscribed to, otherwise, it&rsquo;s an error. If all the checks have been
  passed, the command will be executed, by calling <code>call()</code> with the
  client object and the command object as arguments.</p>

  <h3 id="executing-the-command-and-responding">Executing the command and
  responding</h3>

  <p><code>call()</code>, gets a pointer to function of type <code>struct
  redisCommandProc</code>, from the <code>proc</code> member of the
  <code>command</code> object, which takes a single argument, that of a client
  object. The Redis command procedure is called.</p>

  <div class="codehilite">
    <pre>
<span class="c1">// redis.c:864</span>
<span class="kt">void</span> <span class="nf">call</span><span class=
"p">(</span><span class="n">redisClient</span> <span class=
"o">*</span><span class="n">c</span><span class="p">,</span> <span class=
"k">struct</span> <span class="n">redisCommand</span> <span class=
"o">*</span><span class="n">cmd</span><span class="p">)</span> <span class=
"p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class=
"n">dirty</span><span class="p">;</span>

    <span class="n">dirty</span> <span class="o">=</span> <span class=
"n">server</span><span class="p">.</span><span class=
"n">dirty</span><span class="p">;</span>
    <span class="n">cmd</span><span class="o">-&gt;</span><span class=
"n">proc</span><span class="p">(</span><span class="n">c</span><span class=
"p">);</span>
    <span class="n">dirty</span> <span class="o">=</span> <span class=
"n">server</span><span class="p">.</span><span class=
"n">dirty</span><span class="o">-</span><span class=
"n">dirty</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ...</span>
</pre>
  </div>

  <p>(Sidebar: Each Redis command is responsible for setting the reply for the
  client. This is possible because the signature of a Redis command procedure
  is of a single argument, which is the client object. Likewise, each command
  procedure is responsible for encoding, or deserializing, arguments from the
  command, and for decoding, or serializing, Redis objects in memory for
  response to the client.) Write commands, like <code>SET</code> and
  <code>ZADD</code>, make the server &ldquo;dirty,&rdquo; in other words, the
  server is marked as having pages in memory that have changed. This is
  important for the automatic save process, which keeps track of how many keys
  have changed in a certain period, or the writing to the AOF. The function
  calls <code>feedAppendOnlyFile()</code> if use of the AOF has been enabled,
  which writes out the command buffer from the client to the AOF, so the
  command can be replayed. (It translates commands that set a relative key
  expiration to an absolute expiration, but otherwise it basically copies the
  command as it came in from the client, see
  <code>catAppendOnlyGenericCommand()</code>.) If any slaves are connected,
  <code>call()</code> will send the command to each of them to be executed
  locally, see <code>replicationFeedSlaves()</code>. Likewise, if any clients
  are connected and have issued the <code>MONITOR</code> command, Redis will
  send a representation of the command, prefixed with a timestamp, see
  <code>replicationFeedMonitors()</code>.</p>

  <div class="codehilite">
    <pre>
<span class="c1">// redis.c:871 (call() cont.'d)</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class=
"n">appendonly</span> <span class="o">&amp;&amp;</span> <span class=
"n">dirty</span><span class="p">)</span>
        <span class="n">feedAppendOnlyFile</span><span class=
"p">(</span><span class="n">cmd</span><span class="p">,</span><span class=
"n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class=
"o">-&gt;</span><span class="n">id</span><span class="p">,</span><span class=
"n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class=
"p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class=
"n">argc</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class=
"n">dirty</span> <span class="o">||</span> <span class=
"n">cmd</span><span class="o">-&gt;</span><span class=
"n">flags</span> <span class="o">&amp;</span> <span class=
"n">REDIS_CMD_FORCE_REPLICATION</span><span class="p">)</span> <span class=
"o">&amp;&amp;</span>
        <span class="n">listLength</span><span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class=
"n">slaves</span><span class="p">))</span>
        <span class="n">replicationFeedSlaves</span><span class=
"p">(</span><span class="n">server</span><span class="p">.</span><span class=
"n">slaves</span><span class="p">,</span><span class="n">c</span><span class=
"o">-&gt;</span><span class="n">db</span><span class=
"o">-&gt;</span><span class="n">id</span><span class="p">,</span><span class=
"n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class=
"p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class=
"n">argc</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class=
"n">listLength</span><span class="p">(</span><span class=
"n">server</span><span class="p">.</span><span class=
"n">monitors</span><span class="p">))</span>
        <span class="n">replicationFeedMonitors</span><span class=
"p">(</span><span class="n">server</span><span class="p">.</span><span class=
"n">monitors</span><span class="p">,</span><span class="n">c</span><span class=
"o">-&gt;</span><span class="n">db</span><span class=
"o">-&gt;</span><span class="n">id</span><span class="p">,</span><span class=
"n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class=
"p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class=
"n">argc</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class=
"n">stat_numcommands</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre>
  </div>

  <p>Control returns to the caller, <code>processCommand()</code>, which resets
  the client object for subsequent commands.</p>

  <p>As mentioned, each Redis command procedure is itself responsible for
  setting the response to be sent to the client. After
  <code>readQueryFromClient()</code> exits and Redis returns the to event loop
  in <code>aeMain()</code>, <code>aeProcessEvents()</code> will pick up the
  waiting response in the write buffer and will copy it to the socket the
  client is connected on.</p>

  <p>And that&rsquo;s it! The response has been sent, and both client and
  server are back to a state where they can respectively emit and process more
  Redis commands.</p>

  <h2 id="summary">Summary</h2>

  <p>Redis starts up by initializing a global server state variable, and
  reading in an optional configuration file to override any defaults. It sets
  up a global command table that connects command names with the actual
  function that implements the command. It creates an event loop using the best
  available underlying system library for event/readiness notification, and
  registers a handler function for when there is a new client socket connection
  to accept. It also registers a periodic (i.e., time-based) event handler for
  dealing with <code>cron</code>-like tasks like key expiry that need to be
  addressed outside the regular client-handling path. Once a client has
  connected, a function is registered on the event loop for being notified when
  the client has data to be read (i.e., a query for a command). The
  client&rsquo;s query is parsed and a command handler is called to execute the
  command and write the response back to the client (the writing of data to the
  client is also handled by the event-notification loop). The client object is
  reset and server is ready to process more queries.</p>

  <h2 id="next-time-tracing-a-set-and-get">Next time &mdash; tracing a
  <code>SET</code> and <code>GET</code></h2>

  <p>I&rsquo;ll follow-up this article with one that takes a close look at the
  processing of two commands, <code>SET</code> and <code>GET</code>, by
  stepping through the implementation of each command&rsquo;s procedure and
  examining the data structures Redis uses to store and index data.</p>

  <p>&mdash;<a href="/">Paul Smith</a> (<a href="http://twitter.com/paulsmith">follow me on the Twitter</a>)</p>

  <p><em>Thanks to pietern on <code>#redis</code> for feedback on a draft of
  this article</em></p>

  <p><time datetime="2010-10-18" pubdate>October 18, 2010</time></p>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
_uacct = "UA-304677-1";
urchinTracker();
</script>
</body>
</html>
